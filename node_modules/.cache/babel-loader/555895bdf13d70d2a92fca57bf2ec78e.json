{"ast":null,"code":"import _regeneratorRuntime from \"/Users/kenshin/Documents/UnityProject/useDapp_demo/dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/kenshin/Documents/UnityProject/useDapp_demo/dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/kenshin/Documents/UnityProject/useDapp_demo/dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/kenshin/Documents/UnityProject/useDapp_demo/dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { addressEqual } from '../../src';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\nexport function useContractFunction(contract, functionName, options) {\n  var _useEthers = useEthers(),\n      library = _useEthers.library,\n      chainId = _useEthers.chainId;\n\n  var _usePromiseTransactio = usePromiseTransaction(chainId, options),\n      promiseTransaction = _usePromiseTransactio.promiseTransaction,\n      state = _usePromiseTransactio.state;\n\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      events = _useState2[0],\n      setEvents = _useState2[1];\n\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var contractWithSigner,\n        receipt,\n        _events,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            contractWithSigner = connectContractToSigner(contract, options, library);\n            _context.next = 3;\n            return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _args));\n\n          case 3:\n            receipt = _context.sent;\n\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n              _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n                try {\n                  return addressEqual(log.address, contract.address) ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n                } catch (_err) {\n                  return accumulatedLogs;\n                }\n              }, []);\n              setEvents(_events);\n            }\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [contract, functionName, options, library]);\n  return {\n    send: send,\n    state: state,\n    events: events\n  };\n}","map":null,"metadata":{},"sourceType":"module"}